<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>car-car</title>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<script type="text/javascript">
			var canvas = document.getElementById('canvas');
			var ctx = canvas.getContext('2d');

			var COLORS = {
				SKY:  '#72D7EE',
				TREE: '#005108',
				FOG:  '#005108',
				LIGHT:  { road: '#6B6B6B', grass: '#10AA10', rumble: '#555555', lane: '#CCCCCC'  },
				DARK:   { road: '#696969', grass: '#009A00', rumble: '#BBBBBB'                   },
				START:  { road: 'white',   grass: 'white',   rumble: 'white'                     },
				FINISH: { road: 'black',   grass: 'black',   rumble: 'black'                     }
			};

			var fps = 60;
			var step = 1 / 60;
			var dt = 0;
			var gdt = 0;
			var now = null;
			var last = +new Date();
			var width = 640;
			var height = 480;
			var segments = [];
			var segmentLength = 200;
			var rumbleLength = 3;
			var lanes = 3;
			var trackLength;
			var maxDistance = 500;
			var drawDistance = 300;
			var position = 0;
			var fieldOfView = 100;
			var cameraDepth = 1 / Math.tan((fieldOfView/2) * Math.PI/180);
			var playerX = 0;
			var playerZ;
			var cameraHeight = 1000;
			var roadWidth = 2000;

			// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
			if (!window.requestAnimationFrame) {
				window.requestAnimationFrame = window.webkitRequestAnimationFrame || 
					window.mozRequestAnimationFrame    || 
					window.oRequestAnimationFrame      || 
					window.msRequestAnimationFrame     ||
					function(callback, element) {
						window.setTimeout(callback, 1000 / 60);
					}
			}

			function project(p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth) {
				p.camera.x     = (p.world.x || 0) - cameraX;
				p.camera.y     = (p.world.y || 0) - cameraY;
				p.camera.z     = (p.world.z || 0) - cameraZ;
				p.screen.scale = cameraDepth/p.camera.z;
				p.screen.x     = Math.round((width/2)  + (p.screen.scale * p.camera.x  * width/2));
				p.screen.y     = Math.round((height/2) - (p.screen.scale * p.camera.y  * height/2));
				p.screen.w     = Math.round(             (p.screen.scale * roadWidth   * width/2));
			}

			function rumbleWidth(roadWidth, lanes) {
				return roadWidth / Math.max(6, 2 * lanes);
			}

			function laneMarkerWidth(roadWidth, lanes) {
				return roadWidth / Math.max(32, 8 * lanes);
			}

			function polygon(ctx, x1, y1, x2, y2, x3, y3, x4, y4, color) {
				ctx.save();
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.lineTo(x3, y3);
				ctx.lineTo(x4, y4);
				ctx.fill();
				ctx.restore();
			}

			function segment(ctx, width, lanes, x1, y1, w1, x2, y2, w2, color) {
				var r1 = rumbleWidth(w1, lanes),
					r2 = rumbleWidth(w2, lanes),
					lm1 = laneMarkerWidth(w1, lanes),
					lm2 = laneMarkerWidth(w2, lanes);

				ctx.save();

				ctx.fillStyle = color.grass;
    			ctx.fillRect(0, y2, width, y1 - y2);

    			//right rumble
				polygon(ctx, x1-w1-r1, y1, x1-w1, y1, x2-w2, y2, x2-w2-r2, y2, color.rumble);
				//left rumble
				polygon(ctx, x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);
				//road
				polygon(ctx, x1-w1,    y1, x1+w1, y1, x2+w2, y2, x2-w2,    y2, color.road);

    			ctx.restore();
			}

			function findSegment(z) {
				return segments[Math.floor(z/segmentLength) % segments.length];
			}

			function resetRoad() {
				segments = [];
				for(var n = 0; n < maxDistance; n++) {
					segments.push({
						index: n,
						p1: { world: { z:  n   *segmentLength }, camera: {}, screen: {} },
						p2: { world: { z: (n+1)*segmentLength }, camera: {}, screen: {} },
						color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
					});
				}
				trackLength = segments.length * segmentLength;
			};

			function sleep(t) {
				var s = +new Date(), n;
				do{
					n = +new Date();
				} while(n - s <= t)
			}

			function frame() {
				now = +new Date();
				// dt:前一帧动画的耗时,单位是秒,最大值为1
				dt  = Math.min(30/1000, (now - last) / 1000); 
				// gdt:
				gdt = gdt + dt;
				while (gdt > step) {
					gdt = gdt - step;
					update(step);
				}
				render();
				last = now;
				requestAnimationFrame(frame);
			}

			function update() {
				position += 50;
				if(position >= trackLength) {
					position -= trackLength;
				}
			}

			function drawSky() {
				ctx.save();
				ctx.fillStyle = COLORS.SKY;
				ctx.fillRect(0, 0, width, height);
				ctx.restore();
			}

			function render() {
				var baseSegment = findSegment(position);
				var maxy        = height;

				// clear canvas
				ctx.clearRect(0, 0, width, height);

				drawSky();

				for(var i = 0; i < drawDistance; i++) {
					var s = segments[(baseSegment.index + i) % segments.length];
					//s.looped = s.index < baseSegment.index;

					project(s.p1, playerX * roadWidth, cameraHeight, position/* - (s.looped ? trackLength : 0)*/, cameraDepth, width, height, roadWidth);
					project(s.p2, playerX * roadWidth, cameraHeight, position/* - (s.looped ? trackLength : 0)*/, cameraDepth, width, height, roadWidth);

					if ( (s.p1.camera.z <= cameraDepth) || // behind us
						(s.p2.screen.y >= maxy) ) {// clip by (already rendered) segment
						continue;
					}

					segment(ctx, width, lanes, 
						s.p1.screen.x, 
						s.p1.screen.y, 
						s.p1.screen.w, 
						s.p2.screen.x, 
						s.p2.screen.y, 
						s.p2.screen.w, 
						s.color);

					//maxy = s.p2.screen.y;
				}
			}

			canvas.width = width;
			canvas.height = height;

			resetRoad();
			//render();
			frame();
		</script>
	</body>
</html>